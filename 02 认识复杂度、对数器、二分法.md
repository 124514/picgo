# 02 认识复杂度、对数器、二分法
![](https://cdn.jsdelivr.net/gh/124514/cdn@master/265123723238788.png)
## 算法评价优劣的核心指标 
![](https://cdn.jsdelivr.net/gh/124514/cdn@master/69873823226655.png)
### 时间复杂度
![](https://cdn.jsdelivr.net/gh/124514/cdn@master/238160301231800.png)

![](https://gitee.com/dalongxiadlx/picgo/raw/master/img/167854023246821.png)
常数操作 在算法中表示固定时间的操作 如图 1+1 和 170345456+45646的时间是一样的 
算术运算在算法中视为常数操作 
数组寻址 在算法中也视为常数操作
<mark>数组逻辑上是个连续区域</mark>
![](https://gitee.com/dalongxiadlx/picgo/raw/master/img/567784323239490.png)
<mark>时间复杂度讨论的是  执行完 整个流程 常数操作的数量是个 什么级别的关系</mark>

## 选择排序
### 选择排序原理
![](https://gitee.com/dalongxiadlx/picgo/raw/master/img/224064623236045.png)
时间复杂度 是o(n^2） 时间复杂度 只是比较的 最高次数项 不考虑常数项 不考虑系数

### 代码——选择排序
![](https://gitee.com/dalongxiadlx/picgo/raw/master/img/310091001226027.png)
```java
	public static void selectionSort(int[] arr) {
		if (arr == null || arr.length < 2) {
			return;
		}
		// 0 ~ N-1  找到最小值，在哪，放到0位置上
		// 1 ~ n-1  找到最小值，在哪，放到1 位置上
		// 2 ~ n-1  找到最小值，在哪，放到2 位置上
		for (int i = 0; i < arr.length - 1; i++) {
			int minIndex = i;
			for (int j = i + 1; j < arr.length; j++) { // i ~ N-1 上找最小值的下标 
				minIndex = arr[j] < arr[minIndex] ? j : minIndex;
			}
			swap(arr, i, minIndex);
		}
	}

	public static void swap(int[] arr, int i, int j) {
		int tmp = arr[i];
		arr[i] = arr[j];
		arr[j] = tmp;
	}
```
### 自己写的选择排序
```java
public void selectsort(int[] arr){//选择排序 找最小值放到最前面
            for (int i = 0; i < arr.length-1; i++) {
                int minIndex = i;
                int temp = 0;
                for (int j = i+1; j <arr.length; j++) {
                    if(arr[j]<arr[minIndex]){
                        minIndex = j;

                    }
                }//要每次找到最小值的序号之后 才i和minindex交换值 更新最小值
                temp = arr[minIndex];
                arr[minIndex] = arr[i];
                arr[i] = temp;
            }
```
<mark>交换操作 应该在第一个循环以内  内层循环以外 每次i++之时需要更新一次最小值 把最小值与i交换 而不是在两层循环外表示找出所有最小值中最小的再交换</mark>

## 常见的常数时间操作
跟上面一样：
常数操作 在算法中表示固定时间的操作 如图 1+1 和 170345456+45646的时间是一样的 
算术运算在算法中视为常数操作 
数组寻址 在算法中也视为常数操作
![](https://cdn.jsdelivr.net/gh/124514/cdn@master/163740401249680.png)

### 介绍一个奇葩的时间复杂的——关于数组取值的奇葩案例 
数组取值一般是常数时间，o(1) 但是看下面这个案例 
![](https://gitee.com/dalongxiadlx/picgo/raw/master/img/382200601247284.png)
调用了 list.get（i）  i从0到n   get(i)函数 要从 0——i遍历才能拿出来 那么每次都从0开始  则整个时间复杂度是o(n^2)

## 确定时间复杂度的方法
![](https://gitee.com/dalongxiadlx/picgo/raw/master/img/239710901244786.png)

## 冒泡排序
### 冒泡排序原理分析
![](https://gitee.com/dalongxiadlx/picgo/raw/master/img/459634001248467.png)
时间复杂度是o(n^2)  并且不能改变 不管初始排序的多好 
### 代码——冒泡排序
老师略
```java
public static void bubbleSort(int[] arr) {
		if (arr == null || arr.length < 2) {
			return;
		}
		// 0 ~ N-1
		// 0 ~ N-2
		// 0 ~ N-3
		for (int e = arr.length - 1; e > 0; e--) { // 0 ~ e
			for (int i = 0; i < e; i++) {
				if (arr[i] > arr[i + 1]) {
					swap(arr, i, i + 1);
				}
			}
		}
	}
```
<mark>这是固定最大值到末尾的写法</mark>
### 自己写的冒泡排序代码
```java
//从小到大排序
        int temp = 0;
        public void bubblesort(int[] arr){
            for (int i = 0; i < arr.length-1; i++) {//几轮排序 每次排序把最小固定到前面 随i++递增
                for (int j = 0; j < arr.length-1-i;j++) {//每次两两排序次数 前面的固定i个
                    if(arr[j]>arr[j+1]){//如果前面比后面大 交换
                        temp = arr[j];
                        arr[j] = arr[j+1];
                        arr[j+1] = temp;
                    }
                }
           }
      }
```
<mark>这是固定最小值到开头的写法</mark>
![](https://gitee.com/dalongxiadlx/picgo/raw/master/img/514714601243603.png)

## 插入排序 
### 插入排序时间复杂度
![](https://gitee.com/dalongxiadlx/picgo/raw/master/img/446915501220813.png)
### 插入排序原理分析
![](https://gitee.com/dalongxiadlx/picgo/raw/master/img/315634701237149.png)

### 代码——插入排序
![](https://gitee.com/dalongxiadlx/picgo/raw/master/img/64554901230283.png)
```java
public static void insertionSort(int[] arr) {
		if (arr == null || arr.length < 2) {
			return;
		}
		// 不只1个数
		for (int i = 1; i < arr.length; i++) { // 0 ~ i 做到有序
			for (int j = i - 1; j >= 0 && arr[j] > arr[j + 1]; j--) {
				swap(arr, j, j + 1);
			}
		}
	}
```

### 自己写的代码
```java
public void InsertSort(int[] arr){
        //0-0上有序 已经完成
        //0-1上 0-2  0-3 0-4 0-i上
        for (int i = 0; i <arr.length ; i++) {
            //眼睛盯着的是i  i-1=j是我们眼睛盯着的左边一个数
            for (int j = i-1; j >=0 && arr[j]>arr[j+1]; j--) {
                temp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = temp;

            }
        }
    }
```

## 冒泡排序和插入排序时间复杂度上的区别
![](https://gitee.com/dalongxiadlx/picgo/raw/master/img/206055701223317.png)
![](https://gitee.com/dalongxiadlx/picgo/raw/master/img/534895701232264.png)

## 额外空间复杂度
![](https://gitee.com/dalongxiadlx/picgo/raw/master/img/334175801225149.png)
![](vx_images/41215901225758.png)

## 算法时间复杂度一样 怎么比较好坏
![](https://gitee.com/dalongxiadlx/picgo/raw/master/img/487805901252713.png)
<mark>进入拼常数阶段  放弃理论分析 理论分析涉及了太多的因素 直接大样本随机测试</mark>
## 面试 比赛 刷题中的最优解是什么
![](https://gitee.com/dalongxiadlx/picgo/raw/master/img/145230202234926.png)

## 常见时间复杂度优劣排序
![](https://gitee.com/dalongxiadlx/picgo/raw/master/img/452620202224224.png)
## 对数器
![](https://gitee.com/dalongxiadlx/picgo/raw/master/img/44590402220614.png)
怎么试也是关键 
![](https://gitee.com/dalongxiadlx/picgo/raw/master/img/209121802225769.png)
![](https://gitee.com/dalongxiadlx/picgo/raw/master/img/285740402232704.png)
![](vx_images/340502237743.png)

### 对数器举例——测试插入排序 
![](https://gitee.com/dalongxiadlx/picgo/raw/master/img/310780502239038.png)
#### 代码——主方法 
```java
// for test
	public static void main(String[] args) {
		int testTime = 500000;
		int maxSize = 100; // 随机数组的长度0～100
		int maxValue = 100;// 值：-100～100
		boolean succeed = true;
		for (int i = 0; i < testTime; i++) {
			int[] arr = generateRandomArray(maxSize, maxValue);
			int[] arr1 = copyArray(arr);
			int[] arr2 = copyArray(arr);
			insertionSort(arr1);
			comparator(arr2);
			if (!isEqual(arr1, arr2)) {
				// 打印arr1
				// 打印arr2
				succeed = false;
				for (int j = 0; j < arr.length; j++) {
					System.out.print(arr[j] + " ");
				}
				System.out.println();
				break;
			}
		}
		System.out.println(succeed ? "Nice!" : "Fucking fucked!");

```
#### 说明 comparator方法是调用系统自带的sort函数
```java
public static void comparator(int[] arr) {
		Arrays.sort(arr);
	}
```
包含了三个方法 copyArray generateRandomArray  isEqual
老师之讲解 generateRandomArray  其余两个方法
#### 补充isEqual方法代码
```java
public static boolean isEqual(int[] arr1, int[] arr2) {
		if ((arr1 == null && arr2 != null) || (arr1 != null && arr2 == null)) {
			return false;
		}
		if (arr1 == null && arr2 == null) {
			return true;
		}
		if (arr1.length != arr2.length) {
			return false;
		}
		for (int i = 0; i < arr1.length; i++) {
			if (arr1[i] != arr2[i]) {
				return false;
			}
		}
		return true;
	}
```
#### 补充copyArray方法
```java
public static int[] copyArray(int[] arr) {
		if (arr == null) {
			return null;
		}
		int[] res = new int[arr.length];//res的长度直接新建一个新的数组
		for (int i = 0; i < arr.length; i++) {
			res[i] = arr[i];
		}//挨个拷贝 
		return res;
	}
```
<mark>注意此种拷贝方法生成的不同内存区域的 </mark>


### 讲解其中的生成随机数组方法
![](https://gitee.com/dalongxiadlx/picgo/raw/master/img/56640702240040.png)
#### generateRandomArray方法代码
```java
public static int[] generateRandomArray(int maxSize, int maxValue) {
		// Math.random() -> [0,1) 所有的小数，等概率返回一个
		// Math.random() * N -> [0,N) 所有小数，等概率返回一个
		// (int)(Math.random() * N) -> [0,N-1] 所有的整数，等概率返回一个
		int[] arr = new int[(int) ((maxSize + 1) * Math.random())]; // 长度随机
		for (int i = 0; i < arr.length; i++) {
			arr[i] = (int) ((maxValue + 1) * Math.random()) - (int) (maxValue * Math.random());
		}
		return arr;
	}
```

### 大样本出错了 怎么检查的方法
![](https://gitee.com/dalongxiadlx/picgo/raw/master/img/471880702240217.png)

## 二分法
![](https://gitee.com/dalongxiadlx/picgo/raw/master/img/158352102231860.png)
![](vx_images/277841902235093.png)
本课后面会讲
![](https://gitee.com/dalongxiadlx/picgo/raw/master/img/545972102222191.png)

### 有序数组中 找某个数是否存在
![](https://gitee.com/dalongxiadlx/picgo/raw/master/img/273522202240234.png)
![](https://gitee.com/dalongxiadlx/picgo/raw/master/img/200862302245989.png)
<mark>注意是 向下取整</mark>

#### 有序数组中 找某个数是否存在代码
![](https://gitee.com/dalongxiadlx/picgo/raw/master/img/190552402246621.png)
![](https://gitee.com/dalongxiadlx/picgo/raw/master/img/214312702237357.png)
```java
public static boolean exist(int[] sortedArr, int num) {
		if (sortedArr == null || sortedArr.length == 0) {
			return false;
		}
		int L = 0;
		int R = sortedArr.length - 1;
		int mid = 0;
		// L..R
		while (L < R) { // L..R 至少两个数的时候
			mid = L + ((R - L) >> 1);
			if (sortedArr[mid] == num) {
				return true;
			} else if (sortedArr[mid] > num) {
				R = mid - 1;
			} else {
				L = mid + 1;
			}
		}
		return sortedArr[L] == num;
	}
```

<mark>mid = L + ((R - L) >> 1是有讲究的  如果 （l+r）/2会产生 数据溢出 如上面例子 19亿 20亿相加超过了
注意 L<R和 L<=R的区别 
L<R 有两个 退出时 还有一个数没有验 还需要 return sortedArr[L] == num; 此句是个判断语句 看最后剩下的那个数L=R（默认取L）是不是=num 如果是则true
 L<=R不需要</mark>
### 有序数组中 找>=某个数最左边的位置 
#### 原理讲解
![](https://gitee.com/dalongxiadlx/picgo/raw/master/img/591802802230216.png)
![](https://gitee.com/dalongxiadlx/picgo/raw/master/img/205672902249025.png)

#### 代码
![](https://gitee.com/dalongxiadlx/picgo/raw/master/img/220913002244133.png)
<mark>注意 L<R和 L<=R的区别 
L<R 有两个 退出时 还有一个数没有验 还需要 进一步验证;
 L<=R不需要</mark>
```java
// 在arr上，找满足>=value的最左位置
public static int nearestIndex(int[] arr, int value) {
		int L = 0;
		int R = arr.length - 1;
		int index = -1; // 记录最左的对号
		while (L <= R) { // 至少一个数的时候
			int mid = L + ((R - L) >> 1);
			if (arr[mid] >= value) {
				index = mid;
				R = mid - 1;
			} else {
				L = mid + 1;
			}
		}
		return index;
	}
```
### 有序数组中找小于等于某个数最右边的位置——同理
老师略
#### 代码
```java
// 在arr上，找满足<=value的最右位置
	public static int nearestIndex(int[] arr, int value) {
		int L = 0;
		int R = arr.length - 1;
		int index = -1; // 记录最右的对号
		while (L <= R) {
			int mid = L + ((R - L) >> 1);
			if (arr[mid] <= value) {
				index = mid;
				L = mid + 1;
			} else {
				R = mid - 1;
			}
		}
		return index;
	}
```
### 局部最小问题
<mark>局部最小的要求是 数组无序 有正有负有0 并且相邻两个数不相等</mark>
#### 原理分析
![](https://gitee.com/dalongxiadlx/picgo/raw/master/img/314553802251644.png)
![](https://gitee.com/dalongxiadlx/picgo/raw/master/img/549613802250655.png)

#### 局部最小的代码
![](https://gitee.com/dalongxiadlx/picgo/raw/master/img/291313902237995.png)
```java
public static int getLessIndex(int[] arr) {
		if (arr == null || arr.length == 0) {
			return -1;
		}
		if (arr.length == 1 || arr[0] < arr[1]) {
			return 0;
		}
		if (arr[arr.length - 1] < arr[arr.length - 2]) {
			return arr.length - 1;
		}
		int left = 1;
		int right = arr.length - 2;
		int mid = 0;
		while (left < right) {
			mid = (left + right) / 2;
			if (arr[mid] > arr[mid - 1]) {
				right = mid - 1;
			} else if (arr[mid] > arr[mid + 1]) {
				left = mid + 1;
			} else {//既不比左边大 也不比右边大 还规定不能相等 所以只有 mid最小 左右都比mid大 就直接找到了
				return mid;
			}
		}
		return left;
	}
```
<mark>最后 因为while (left < right)  最后退出的时候会还剩一个 最后那个左边=右边 所以也是默认左边 return left</mark>
